## 步骤（一个类只有一个对象实例）
 * 1.将构造方法私有化
 * 2.在该类内部产生一个唯一实例化对象，并将封装为private static
 * 3.定义一个静态方法获取返回这个唯一对象

---
## 实现（4种方法）
实现一：立即加载 / “饿汉模式”   
实现二：延迟加载 / “懒汉模式”   
实现三：线程安全的“懒汉模式”   
实现四：DCL双检查锁机制（DCL：double checked locking）   

---
###### 实现一：立即加载 / “饿汉模式”
```html
优点：实现简单，没多线程同步问题
缺点：耗费内存，类加载后，静态变量，instance被初始化，并分配内存空间，一直占用着
```


###### 实现二：延迟加载 / “懒汉模式”   
```html
优点：实现简单，节省内存
缺点：在多线程下这个方法是错误的，无法保证单例
```


###### 实现三：线程安全的“懒汉模式” 
```html
优点：实现简单，多线程下也是安全的
缺点：众所周知，在多线程下用synchronize方法效率低，不是最佳方案
```

  
###### 实现四：DCL双检查锁机制（DCL：double checked locking） 【推荐使用】 
```html
优点：效率高，线程安全，多线程操作原子性（有问题）
缺点：内存占用高

问题：jdk1.5之前，在构造单例对象是，会出现指令重排序 ps:实例的写入操作和实例的字段写入操作存在重排序问题
当然这个bug已经修复了，SUN官方调整了JVM，加上Volatile

// 获取FlameFactory
private volatile static FlameFactory flameFactory=null;
```

###### 其他
1.静态内部类
2.枚举类

